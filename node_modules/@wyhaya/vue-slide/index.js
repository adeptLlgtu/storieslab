'use strict';

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
require('./index.css');

var script = {
  props: {
    data: {
      "default": [],
      type: Array
    },
    time: {
      "default": 3000,
      type: Number
    },
    speed: {
      "default": 300,
      type: Number
    },
    spot: {
      "default": true,
      type: Boolean
    },
    type: {
      "default": 'ease',
      type: String
    },
    clockwise: {
      "default": true,
      type: Boolean
    }
  },
  data: function data() {
    return {
      cur: 0,
      slideX: 0,
      transition: 0,
      touch: {
        startX: 0,
        // 触摸的初始位置 X
        startY: 0,
        // 触摸的初始位置 Y
        ifN: false,
        // 确定是否需要触摸移动的时候需要判断
        direction: false,
        // 确定是向上滚动还是向下滚动
        timer: null,
        // 定时滚动的定时器
        duration: 0,
        // 触摸了时间
        scrollDirection: false // 滚动方向

      }
    };
  },
  mounted: function mounted() {
    this.setTimer();
  },
  computed: {
    prevItem: function prevItem() {
      var item = this.data[this.cur - 1];
      return item ? item : this.data[this.data.length - 1];
    },
    nextItem: function nextItem() {
      var item = this.data[this.cur + 1];
      return item ? item : this.data[0];
    }
  },
  methods: {
    getGap: function getGap(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return parseInt((x - y).toString().replace('-', ''));
    },
    touchStart: function touchStart(e) {
      this.touch.startX = e.touches[0].clientX;
      this.touch.startY = e.touches[0].clientY;
      this.touch.ifN = true;
      this.touch.duration = new Date().getTime();
      window.clearInterval(this.touch.timer);
      this.transition = 0;
    },
    touchMove: function touchMove(e) {
      if (this.touch.ifN) {
        if (this.getGap(e.touches[0].clientX, this.touch.startX) >= this.getGap(e.touches[0].clientY, this.touch.startY)) {
          this.touch.direction = true;
          e.currentTarget.style.transition = '';
        } else this.touch.direction = false;

        this.touch.ifN = false;
      } else {
        // 根据状态来判断是否滚动
        if (this.touch.direction) {
          e.preventDefault();
          this.slideX = e.touches[0].clientX - this.touch.startX;
        }
      }
    },
    touchEnd: function touchEnd() {
      this.setTimer();
      if (!this.touch.direction) return; // 接触的时间

      var time = new Date().getTime() - this.touch.duration; // 如果超过300毫秒 那么判断是否滑动到下一个上一个轮播的依据为 滑动的距离是否超过轮播宽度的三分之一

      if (time > 300 && this.getGap(this.slideX) < this.$refs.contentRef.offsetWidth / 3) {
        // 还原 的速度为 过渡时间的0.8倍
        this.touch.scrollDirection = false;
        this.transition = this.speed * 0.8;
        this.slideX = 0;
      } else {
        // 防止点击时滑动
        if (this.slideX !== 0) {
          this.slideX > 0 ? this.prev() : this.next();
        }
      }
    },
    prev: function prev() {
      this.touch.scrollDirection = 'prev';
      this.transition = this.speed;
      this.slideX = this.$refs.contentRef.offsetWidth;
    },
    next: function next() {
      this.touch.scrollDirection = 'next';
      this.transition = this.speed;
      this.slideX = -this.$refs.contentRef.offsetWidth;
    },
    transitionEnd: function transitionEnd() {
      var cur = 0;

      if (this.touch.scrollDirection === false) {
        cur = this.cur;
      } else {
        if (this.touch.scrollDirection === 'prev') {
          if (this.cur === 0) {
            cur = this.data.length - 1;
          } else {
            cur = this.cur - 1;
          }

          this.$emit('prev', cur);
        } else {
          if (this.cur !== this.data.length - 1) {
            cur = this.cur + 1;
          }

          this.$emit('next', cur);
        }
      }

      if (this.cur !== cur) {
        this.$emit('change', cur);
      }

      this.transition = 0;
      this.slideX = 0;
      this.cur = cur;
    },
    setTimer: function setTimer() {
      if (this.time) {
        this.touch.timer = setInterval(this.clockwise ? this.next : this.prev, this.time);
      }
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function () {
      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}

var normalizeComponent_1 = normalizeComponent;

/* script */
var __vue_script__ = script;
/* template */

var __vue_render__ = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    ref: "contentRef",
    staticClass: "vue-slide"
  }, [_c('div', {
    staticClass: "content",
    style: {
      transform: "translate3d(" + _vm.slideX + "px, 0px, 0px)",
      transition: "transform " + _vm.transition / 1000 + "s " + _vm.type
    },
    on: {
      "touchstart": _vm.touchStart,
      "touchmove": _vm.touchMove,
      "touchend": _vm.touchEnd,
      "transitionend": _vm.transitionEnd
    }
  }, [_c('div', [_c('img', {
    attrs: {
      "src": _vm.prevItem
    }
  })]), _vm._v(" "), _c('div', [_c('img', {
    attrs: {
      "src": _vm.data[_vm.cur]
    },
    on: {
      "click": function click($event) {
        return _vm.$emit('click', _vm.cur);
      }
    }
  })]), _vm._v(" "), _c('div', [_c('img', {
    attrs: {
      "src": _vm.nextItem
    }
  })])]), _vm._v(" "), _vm.spot ? _c('div', {
    staticClass: "spot"
  }, _vm._l(_vm.data.length, function (d, i) {
    return _c('div', {
      key: i,
      "class": {
        cur: i === _vm.cur
      }
    });
  }), 0) : _vm._e()]);
};

var __vue_staticRenderFns__ = [];
/* style */

var __vue_inject_styles__ = undefined;
/* scoped */

var __vue_scope_id__ = undefined;
/* module identifier */

var __vue_module_identifier__ = undefined;
/* functional template */

var __vue_is_functional_template__ = false;
/* style inject */

/* style inject SSR */

var index = normalizeComponent_1({
  render: __vue_render__,
  staticRenderFns: __vue_staticRenderFns__
}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, undefined, undefined);

module.exports = index;
